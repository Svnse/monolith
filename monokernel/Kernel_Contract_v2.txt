MONOLITH KERNEL CONTRACT — v2 (FROZEN)
0. Purpose

The Monolith kernel is a four-layer execution hierarchy:

UI → MonoBridge → MonoDock → MonoGuard → Engines


Three flows. No exceptions.

Flow	Direction	Behavior
Commands	Downward	UI → Bridge → Dock → Guard → Engine
State	Upward	Engine → Guard → UI
STOP	Instant	Bypasses queues, executes immediately

All execution-affecting functionality routes around this structure, never into it.

1. Authority Gradient

MonoGuard is the sole authority.

Only MonoGuard may:

Initiate engine execution

Interrupt engine execution

Transition engine state

Emit READY

Clear active work

MonoBridge and MonoDock are non-authoritative. They translate, organize, and route. They do not execute or decide.

2. Component Contracts
2.1 MonoBridge (Translator)

Role: Normalize UI intent into Task submission and control requests.

Interface:


def wrap(source: str, command: str, target: str, **kwargs) -> Task
def submit(task: Task) -> None                  # forwards to MonoDock.enqueue
def cancel(task_id: str) -> None                # forwards to MonoDock.cancel_task
def cancel_addon(addon_pid: str) -> None        # forwards to MonoDock.cancel_addon
def stop(target: str = "all") -> None           # forwards STOP to MonoDock.on_stop


Rules:

Creates Task with unique ID, timestamp, payload, origin metadata

Forwards Tasks to MonoDock (never directly to MonoGuard)

For cancel/stop: forwards requests to MonoDock (does not mutate queued state)

Must not:

Queue tasks

Block

Execute engines

Inspect payload semantics

Mutate MonoDock-owned task state

2.2 MonoDock (Organizer)

Role: Queue, prioritize, cancel, and submit Tasks prior to arbitration.

Interface:


def enqueue(task: Task) -> None
def cancel_task(task_id: str) -> None
def cancel_addon(addon_pid: str) -> None
def on_stop(target: str = "all") -> None


State:

queues: dict[str, deque[Task]]        # per-engine FIFO queues (priority-aware)
cancelled_task_ids: set[str]          # fast cancel filter
cancelled_addons: set[str]            # fast cancel filter (by addon_pid)


Rules:

Maintains per-target priority queues (FIFO within same priority)

Filters cancelled tasks before submission

Submits to MonoGuard via guard.submit(task) only

If guard.submit(task) returns False (engine busy): waits for guard.sig_engine_ready(engine_key) to retry

On STOP:

issues immediate stop to MonoGuard (no queue)

marks queued tasks for that target as cancelled (by id or by target sweep)

May request Guard STOP if a cancelled task is currently active (Dock-driven, not Bridge-driven)

Must not:

Execute engines

Emit state signals

Mutate MonoGuard internals

Synthesize READY

Override or delay STOP

2.3 MonoGuard (Authority)

Role: Final execution arbiter.

Interface:


def submit(task: Task) -> bool        # True if accepted, False if engine busy
def stop(target: str = "all") -> None


State:

engines: dict[str, EnginePort]            # registered engines by key
active_tasks: dict[str, Task | None]      # one active task per engine


Signals:

sig_status: Signal(str, SystemStatus)     # (engine_key, status) — authoritative
sig_engine_ready: Signal(str)             # engine_key — emitted only on truthful READY
sig_token: Signal(str)                    # passthrough from engine
sig_trace: Signal(str)                    # passthrough from engine
sig_image: Signal(object)                 # passthrough from engine (optional)
sig_finished: Signal(str, str)            # (engine_key, task_id) optional convenience


Rules:

Routes by task.target engine key

Does not validate payload semantics (engine’s job)

Re-emits engine signals verbatim

Emits sig_engine_ready(engine_key) only when that engine is truthfully READY

Enforces: one active Task per engine

On STOP(target):

interrupts target engine(s) immediately (non-blocking)

clears relevant active_tasks

emits authoritative status transitions

On engine ERROR:

emits status ERROR

clears active task

transitions back to READY (no stuck states)

Dispatch rule (non-semantic):
MonoGuard must not grow command-specific business logic. It may only perform mechanical dispatch to the target engine.

Canonical pattern:

ENGINE_DISPATCH = {
    "set_path": "set_model_path",
    "load": "load_model",
    "unload": "unload_model",
    "generate": "generate",
}


MonoGuard performs method lookup and calls the engine; payload interpretation remains engine-specific.

Must not:

Perform business logic

Block or sleep

Inspect payload meaning

Contain UI logic

Accumulate feature-specific state

2.4 Engines (Workers)

Role: Execute work, emit results.

Rules:

Must implement EnginePort protocol

Must not know about MonoBridge, MonoDock, MonoGuard internals, or UI

Must not emit directly to UI

Must support stop_generation() as an interrupt

3. EnginePort Protocol

All engines implement this interface:

@runtime_checkable
class EnginePort(Protocol):
    # Signals
    sig_status: Signal      # SystemStatus
    sig_trace: Signal       # str
    sig_token: Signal       # str (text stream output, optional)
    sig_image: Signal       # object (image output, optional)
    sig_finished: Signal    # () optional

    # Methods
    def set_model_path(self, path: str) -> None: ...
    def load_model(self) -> None: ...
    def unload_model(self) -> None: ...
    def generate(self, payload: dict) -> None: ...
    def stop_generation(self) -> None: ...
    def shutdown(self) -> None: ...


Payload interpretation is engine-specific:

LLM reads payload["prompt"], payload["config"]

Vision reads payload["prompt"], payload["steps"], payload["seed"]

MonoGuard does not interpret payload content.

4. Task Model (Canonical)

Each command becomes exactly one Task:

@dataclass
class Task:
    id: UUID                    # unique identifier
    addon_pid: str              # source addon instance
    target: str                 # engine key ("llm", "vision", etc.)
    command: str                # "generate", "load", "unload", "set_path", "stop"
    payload: dict               # command-specific data
    priority: int               # 1=STOP, 2=normal, 3=background
    status: TaskStatus          # PENDING/RUNNING/DONE/FAILED/CANCELLED
    timestamp: float            # creation time


Priority semantics:

Priority	Name	Behavior
1	STOP	Bypasses queues, executes immediately
2	Normal	Standard FIFO
3	Background	Yields to normal priority
5. Cancellation vs STOP

Two distinct operations:

Operation	Scope	Effect
Cancel	Task or addon	Prevents queued execution; active execution may be stopped by Dock→Guard
STOP	Engine or all	Interrupts active execution immediately; clears active task; cancels queued tasks for target

Cancel flow:

UI → Bridge.cancel(task_id)
  → Dock.cancel_task(task_id)
  → Dock filters cancelled tasks on submission
  → If cancelled task is active: Dock calls Guard.stop(task.target)


STOP flow:

UI → Bridge.stop(target)
  → Dock.on_stop(target)
  → Guard.stop(target)
  → Engine.stop_generation()
  → Engine emits sig_status(READY)
  → Guard emits sig_engine_ready(target)
  → Dock submits next non-cancelled task


STOP is idempotent. Repeated calls have no additional effect.

6. Execution Model

Concurrency

Multiple engines may execute concurrently

Only one Task per engine at a time

State truth

MonoGuard is the sole source of execution state

UI subscribes to Guard signals, never Engine signals

READY means: no active task and accepting new work

Error handling

Engine errors emit sig_status(ERROR)

MonoGuard clears the active task and transitions back to READY

No stuck states

7. Stability Guarantees

Breaking any of the following requires a major contract revision:

Single ingress via MonoBridge

Single egress via MonoGuard

STOP dominance — always priority 1, always immediate

Non-blocking MonoGuard — no sleeps, no waits

Engine isolation — engines know nothing about kernel/UI

One active Task per engine

Truthful READY — emitted only when genuinely idle

8. Extension Rules

Does not belong in kernel if:

Feature can be removed without changing MonoGuard

Feature is UI-specific

Feature is engine-specific (model config, output format)

Requires new kernel version if:

MonoGuard behavior must change

New signal flow pattern required

Authority gradient modified

9. Future Compatibility

Process isolation ready:

MonoBridge may become IPC broker

Task model and authority gradient unchanged

Engines may run in separate processes

New engine registration:

Add key to guard.engines dict

Implement EnginePort

No MonoGuard logic changes required

One-Line Summary

The kernel decides when and where — never what.
